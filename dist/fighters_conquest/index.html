<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fighter's Conquest</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a202c;
            color: #e2e8f0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        .screen {
            display: none;
            width: 100%;
            max-width: 1000px;
            height: 600px;
            background-color: #2d3748;
            border-radius: 1rem;
            border: 4px solid #4a5568;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 2rem;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .screen.active {
            display: flex;
        }
        canvas {
            background-color: #1a202c;
            border-radius: 0.5rem;
            border: 2px solid #4a5568;
            width: 100%;
            height: 400px;
        }
        .btn {
            background-color: #4a5568;
            color: #e2e8f0;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            text-transform: uppercase;
            cursor: pointer;
            border: 2px solid #718096;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .btn:hover {
            background-color: #718096;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.3);
        }
        .character-card {
            background-color: #4a5568;
            border: 2px solid #718096;
            border-radius: 0.5rem;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            text-align: center;
        }
        .character-card:hover, .character-card.selected {
            transform: scale(1.05);
            border-color: #a0aec0;
        }
        .character-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .health-bar-container {
            width: 100%;
            height: 30px;
            background-color: #1a202c;
            border-radius: 0.5rem;
            border: 2px solid #4a5568;
            overflow: hidden;
            position: relative;
        }
        .health-bar {
            height: 100%;
            transition: width 0.3s ease-in-out;
            border-radius: 0.25rem;
        }
        .health-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 0.8rem;
            text-shadow: 1px 1px 2px black;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .modal-content {
            background-color: #2d3748;
            padding: 2rem;
            border-radius: 1rem;
            border: 4px solid #4a5568;
            text-align: center;
        }
    </style>
</head>
<body>

    <!-- Main Menu Screen -->
    <div id="main-menu" class="screen active">
        <h1 class="text-5xl mb-8">Fighter's Conquest</h1>
        <div class="space-y-4">
            <button id="play-btn" class="btn w-64">Play</button>
            <button id="shop-btn" class="btn w-64">Shop</button>
            <button id="download-btn" class="btn w-64">Download Game</button>
        </div>
        <p class="mt-8">Coins: <span id="main-menu-coins">0</span></p>
    </div>

    <!-- Character Select Screen -->
    <div id="character-select" class="screen">
        <h2 class="text-4xl mb-6">Select Your Fighter</h2>
        <div id="character-grid" class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
            <!-- Character cards will be injected here -->
        </div>
        <button id="start-fight-btn" class="btn" disabled>Start Fight</button>
        <button id="back-to-menu-char-select" class="btn mt-4">Back to Menu</button>
    </div>

    <!-- Game Screen -->
    <div id="game-screen" class="screen">
        <div class="w-full flex justify-between items-center mb-2 px-2">
            <!-- Player Stats -->
            <div class="w-2/5">
                <h3 id="player-name" class="text-lg">Player</h3>
                <div class="health-bar-container">
                    <div id="player-health-bar" class="health-bar bg-green-500"></div>
                     <span id="player-health-text" class="health-bar-text">100/100</span>
                </div>
            </div>
            <!-- Timer -->
            <div id="timer" class="text-4xl">60</div>
            <!-- CPU Stats -->
            <div class="w-2/5">
                <h3 id="cpu-name" class="text-lg text-right">CPU</h3>
                <div class="health-bar-container">
                    <div id="cpu-health-bar" class="health-bar bg-red-500"></div>
                    <span id="cpu-health-text" class="health-bar-text">100/100</span>
                </div>
            </div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div class="mt-4 text-center text-sm">
            Move: Arrow Keys | Attack: Spacebar | Special: 'S' Key
        </div>
    </div>

    <!-- Shop Screen -->
    <div id="shop-screen" class="screen">
        <h2 class="text-4xl mb-6">Fighter Shop</h2>
        <p class="mb-6">Your Coins: <span id="shop-coins">0</span></p>
        <div id="shop-grid" class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
            <!-- Shop items will be injected here -->
        </div>
        <button id="back-to-menu-shop" class="btn">Back to Menu</button>
    </div>

    <!-- Upgrade Modal -->
    <div id="upgrade-modal" class="modal hidden">
        <div class="modal-content">
            <h3 id="upgrade-char-name" class="text-2xl mb-4">Upgrade Fighter</h3>
            <div id="upgrade-stats" class="mb-4 text-left">
                <!-- Stats go here -->
            </div>
            <div class="space-y-3">
                <button id="upgrade-health-btn" class="btn w-full"></button>
                <button id="upgrade-attack-btn" class="btn w-full"></button>
                <button id="upgrade-defense-btn" class="btn w-full"></button>
            </div>
            <button id="close-upgrade-modal" class="btn mt-6">Close</button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="modal hidden">
        <div class="modal-content">
            <h2 id="game-over-message" class="text-4xl mb-4">You Win!</h2>
            <p id="coins-earned-message" class="mb-6">You earned 100 coins!</p>
            <button id="play-again-btn" class="btn">Play Again</button>
            <button id="back-to-menu-game-over" class="btn">Main Menu</button>
        </div>
    </div>


    <script>
        // --- DOM ELEMENTS ---
        const screens = {
            mainMenu: document.getElementById('main-menu'),
            characterSelect: document.getElementById('character-select'),
            game: document.getElementById('game-screen'),
            shop: document.getElementById('shop-screen'),
        };
        const buttons = {
            play: document.getElementById('play-btn'),
            shop: document.getElementById('shop-btn'),
            download: document.getElementById('download-btn'),
            startFight: document.getElementById('start-fight-btn'),
            backToMenuFromChar: document.getElementById('back-to-menu-char-select'),
            backToMenuFromShop: document.getElementById('back-to-menu-shop'),
            playAgain: document.getElementById('play-again-btn'),
            backToMenuFromGameOver: document.getElementById('back-to-menu-game-over'),
            closeUpgradeModal: document.getElementById('close-upgrade-modal'),
        };
        const coinsDisplays = {
            mainMenu: document.getElementById('main-menu-coins'),
            shop: document.getElementById('shop-coins'),
        };
        const characterGrid = document.getElementById('character-grid');
        const shopGrid = document.getElementById('shop-grid');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const gameOverModal = document.getElementById('game-over-modal');
        const gameOverMessage = document.getElementById('game-over-message');
        const coinsEarnedMessage = document.getElementById('coins-earned-message');

        const upgradeModal = document.getElementById('upgrade-modal');


        // --- GAME DATA ---
        let playerState = {
            coins: 0,
            unlockedCharacters: ['ryu'],
            characterUpgrades: {}
        };

        const characters = {
            ryu: { name: 'Ryu', color: 'white', cost: 0, baseStats: { health: 100, attack: 15, defense: 5, speed: 5, specialCooldown: 5000 }, special: 'hadoken' },
            ken: { name: 'Ken', color: 'red', cost: 500, baseStats: { health: 90, attack: 17, defense: 4, speed: 6, specialCooldown: 4500 }, special: 'shoryuken' },
            chunli: { name: 'Chun-Li', color: 'blue', cost: 750, baseStats: { health: 85, attack: 12, defense: 3, speed: 8, specialCooldown: 3000 }, special: 'kikoken' },
            zangief: { name: 'Zangief', color: 'yellow', cost: 1000, baseStats: { health: 150, attack: 20, defense: 8, speed: 3, specialCooldown: 8000 }, special: 'lariat' },
        };

        const UPGRADE_COST_BASE = 50;
        const UPGRADE_COST_MULTIPLIER = 1.5;

        // --- GAME STATE ---
        let selectedCharacterKey = null;
        let gameLoopId;
        let timer;
        let timeLeft;
        let player;
        let cpu;
        let projectiles = [];

        // --- GAME CLASSES ---
        class Fighter {
            constructor({ key, isPlayer = false }) {
                const charData = characters[key];
                const upgrades = playerState.characterUpgrades[key] || { health: 0, attack: 0, defense: 0 };

                this.key = key;
                this.name = charData.name;
                this.width = 50;
                this.height = 150;
                this.isPlayer = isPlayer;

                this.maxHealth = charData.baseStats.health + (upgrades.health * 20);
                this.health = this.maxHealth;
                this.attack = charData.baseStats.attack + (upgrades.attack * 3);
                this.defense = charData.baseStats.defense + (upgrades.defense * 2);
                this.speed = charData.baseStats.speed;

                this.position = {
                    x: isPlayer ? 100 : canvas.width - 150,
                    y: canvas.height - this.height,
                };
                this.velocity = { x: 0, y: 0 };
                this.gravity = 0.7;
                this.isAttacking = false;
                this.attackBox = {
                    position: { x: this.position.x, y: this.position.y },
                    width: 100,
                    height: 50,
                };
                this.color = charData.color;

                this.specialAbility = charData.special;
                this.specialCooldown = charData.baseStats.specialCooldown;
                this.lastSpecialTime = 0;
            }

            draw() {
                const x = this.position.x;
                const y = this.position.y;
                const w = this.width;
                const h = this.height;

                ctx.imageSmoothingEnabled = false;

                // Proportions
                const headSize = w * 0.6;
                const torsoWidth = w * 0.8;
                const torsoHeight = h * 0.4;
                const legWidth = w * 0.3;
                const legHeight = h * 0.5;
                const armWidth = w * 0.25;
                const armHeight = h * 0.35;

                const centerX = x + w / 2;
                const torsoY = y + headSize;

                // Draw from back to front for layering

                // ARMS (behind torso)
                ctx.fillStyle = '#e0aa87'; // Skin tone
                if (this.isAttacking) {
                    const punchLength = w * 0.7;
                    // Attacking arm
                    const punchX = this.isPlayer ? centerX : centerX - punchLength;
                    ctx.fillRect(punchX, torsoY + 5, punchLength, armWidth);
                    // Other arm (recoiled)
                    const recoilX = this.isPlayer ? centerX - w*0.5 : centerX;
                    ctx.fillRect(recoilX, torsoY + 5, armWidth, armWidth);
                } else {
                    // Resting arms
                    ctx.fillRect(centerX - torsoWidth / 2 - armWidth, torsoY, armWidth, armHeight); // Left
                    ctx.fillRect(centerX + torsoWidth / 2, torsoY, armWidth, armHeight); // Right
                }

                // LEGS
                ctx.fillStyle = this.color;
                ctx.fillRect(centerX - torsoWidth / 2, torsoY + torsoHeight - legHeight*0.1, legWidth, legHeight);
                ctx.fillRect(centerX + torsoWidth / 2 - legWidth, torsoY + torsoHeight - legHeight*0.1, legWidth, legHeight);

                // TORSO
                ctx.fillRect(centerX - torsoWidth / 2, torsoY, torsoWidth, torsoHeight);

                // HEAD
                ctx.fillStyle = '#e0aa87'; // Skin tone
                ctx.fillRect(centerX - headSize / 2, y, headSize, headSize);

                // HAIR/BANDANA
                ctx.fillStyle = this.color === 'white' ? '#444' : '#A52A2A'; // Dark grey for Ryu, brown for others
                ctx.fillRect(centerX - headSize / 2, y, headSize, headSize * 0.4);

                // EYES
                ctx.fillStyle = 'black';
                const eyeY = y + headSize * 0.4;
                const eyeX = this.isPlayer ? centerX + headSize * 0.1 : centerX - headSize * 0.1 - 4;
                ctx.fillRect(eyeX, eyeY, 4, 4);
            }

            update() {
                this.draw();
                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;

                if (this.position.y + this.height + this.velocity.y >= canvas.height) {
                    this.velocity.y = 0;
                } else {
                    this.velocity.y += this.gravity;
                }

                // Prevent moving off-screen
                if (this.position.x < 0) this.position.x = 0;
                if (this.position.x + this.width > canvas.width) this.position.x = canvas.width - this.width;

                this.attackBox.position.x = this.position.x;
                this.attackBox.position.y = this.position.y + 50;
            }

            performAttack() {
                this.isAttacking = true;
                setTimeout(() => {
                    this.isAttacking = false;
                }, 200);
            }

            performSpecial() {
                const now = Date.now();
                if (now - this.lastSpecialTime < this.specialCooldown) return;
                this.lastSpecialTime = now;

                switch (this.specialAbility) {
                    case 'hadoken':
                    case 'kikoken':
                        projectiles.push(new Projectile({
                            position: { x: this.position.x + this.width, y: this.position.y + 50 },
                            velocity: { x: this.isPlayer ? 7 : -7, y: 0 },
                            owner: this,
                            damage: this.attack * 1.5
                        }));
                        break;
                    case 'shoryuken': // A rising uppercut
                        this.velocity.y = -20;
                        this.performAttack(); // Treat as a stronger, moving attack
                        break;
                    case 'lariat': // A spinning move
                        // This would need more complex animation, for now, a powerful short-range attack
                        this.isAttacking = true;
                        this.attackBox.width = 150;
                        this.attackBox.position.x = this.position.x - 25;
                        setTimeout(() => {
                            this.isAttacking = false;
                            this.attackBox.width = 100;
                        }, 500);
                        break;
                }
            }

            takeDamage(damage) {
                const actualDamage = Math.max(1, damage - this.defense);
                this.health -= actualDamage;
                if (this.health < 0) this.health = 0;
                updateHealthBars();
            }
        }

        class Projectile {
            constructor({ position, velocity, owner, damage }) {
                this.position = position;
                this.velocity = velocity;
                this.width = 30;
                this.height = 30;
                this.color = 'cyan';
                this.owner = owner;
                this.damage = damage;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.position.x + this.width / 2, this.position.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
            }

            update() {
                this.draw();
                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;
            }
        }


        // --- UI & NAVIGATION ---
        function switchScreen(screenName) {
            Object.values(screens).forEach(screen => screen.classList.remove('active'));
            if (screens[screenName]) {
                screens[screenName].classList.add('active');
            }
        }

        function updateCoinDisplays() {
            coinsDisplays.mainMenu.textContent = playerState.coins;
            coinsDisplays.shop.textContent = playerState.coins;
        }

        function populateCharacterSelect() {
            characterGrid.innerHTML = '';
            Object.keys(characters).forEach(key => {
                const char = characters[key];
                const isUnlocked = playerState.unlockedCharacters.includes(key);
                const card = document.createElement('div');
                card.className = `character-card ${isUnlocked ? '' : 'locked'}`;
                card.dataset.key = key;
                card.innerHTML = `<p class="font-bold">${char.name}</p>`;

                if (isUnlocked) {
                    card.onclick = () => {
                        selectedCharacterKey = key;
                        document.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
                        card.classList.add('selected');
                        buttons.startFight.disabled = false;
                    };
                }
                characterGrid.appendChild(card);
            });
        }

        function populateShop() {
            shopGrid.innerHTML = '';
            Object.keys(characters).forEach(key => {
                const char = characters[key];
                const isUnlocked = playerState.unlockedCharacters.includes(key);
                const card = document.createElement('div');
                card.className = 'character-card p-2';
                card.innerHTML = `
                    <p class="font-bold">${char.name}</p>
                    <div class="mt-2">
                        ${isUnlocked
                            ? `<button class="btn text-xs upgrade-btn" data-key="${key}">UPGRADE</button>`
                            : `<button class="btn text-xs buy-btn" data-key="${key}">BUY: ${char.cost}C</button>`
                        }
                    </div>`;

                if (!isUnlocked && playerState.coins < char.cost) {
                    card.querySelector('.buy-btn').disabled = true;
                    card.querySelector('.buy-btn').classList.add('opacity-50', 'cursor-not-allowed');
                }

                shopGrid.appendChild(card);
            });

            document.querySelectorAll('.buy-btn').forEach(btn => {
                btn.onclick = (e) => {
                    const key = e.target.dataset.key;
                    buyCharacter(key);
                };
            });
            document.querySelectorAll('.upgrade-btn').forEach(btn => {
                btn.onclick = (e) => {
                    const key = e.target.dataset.key;
                    openUpgradeModal(key);
                };
            });
        }

        function openUpgradeModal(key) {
            const charData = characters[key];
            const upgrades = playerState.characterUpgrades[key] || { health: 0, attack: 0, defense: 0 };

            document.getElementById('upgrade-char-name').textContent = `Upgrade ${charData.name}`;

            function getUpgradeCost(level) {
                return Math.floor(UPGRADE_COST_BASE * Math.pow(UPGRADE_COST_MULTIPLIER, level));
            }

            const healthCost = getUpgradeCost(upgrades.health);
            const attackCost = getUpgradeCost(upgrades.attack);
            const defenseCost = getUpgradeCost(upgrades.defense);

            document.getElementById('upgrade-stats').innerHTML = `
                <p>Health Lvl: ${upgrades.health} (+${upgrades.health * 20})</p>
                <p>Attack Lvl: ${upgrades.attack} (+${upgrades.attack * 3})</p>
                <p>Defense Lvl: ${upgrades.defense} (+${upgrades.defense * 2})</p>
            `;

            const healthBtn = document.getElementById('upgrade-health-btn');
            healthBtn.textContent = `Upgrade Health (${healthCost}C)`;
            healthBtn.onclick = () => upgradeStat(key, 'health');
            healthBtn.disabled = playerState.coins < healthCost;

            const attackBtn = document.getElementById('upgrade-attack-btn');
            attackBtn.textContent = `Upgrade Attack (${attackCost}C)`;
            attackBtn.onclick = () => upgradeStat(key, 'attack');
            attackBtn.disabled = playerState.coins < attackCost;

            const defenseBtn = document.getElementById('upgrade-defense-btn');
            defenseBtn.textContent = `Upgrade Defense (${defenseCost}C)`;
            defenseBtn.onclick = () => upgradeStat(key, 'defense');
            defenseBtn.disabled = playerState.coins < defenseCost;

            upgradeModal.classList.remove('hidden');
        }

        function upgradeStat(key, stat) {
            const upgrades = playerState.characterUpgrades[key] || { health: 0, attack: 0, defense: 0 };
            const cost = Math.floor(UPGRADE_COST_BASE * Math.pow(UPGRADE_COST_MULTIPLIER, upgrades[stat]));

            if (playerState.coins >= cost) {
                playerState.coins -= cost;
                if (!playerState.characterUpgrades[key]) {
                    playerState.characterUpgrades[key] = { health: 0, attack: 0, defense: 0 };
                }
                playerState.characterUpgrades[key][stat]++;
                saveData();
                updateCoinDisplays();
                openUpgradeModal(key); // Re-open to refresh costs and stats
            }
        }

        function buyCharacter(key) {
            const char = characters[key];
            if (playerState.coins >= char.cost && !playerState.unlockedCharacters.includes(key)) {
                playerState.coins -= char.cost;
                playerState.unlockedCharacters.push(key);
                saveData();
                updateCoinDisplays();
                populateShop();
            }
        }

        // --- GAME LOGIC ---
        function initGame() {
            canvas.width = 1000;
            canvas.height = 450;

            const cpuKeys = Object.keys(characters);
            const randomCpuKey = cpuKeys[Math.floor(Math.random() * cpuKeys.length)];

            player = new Fighter({ key: selectedCharacterKey, isPlayer: true });
            cpu = new Fighter({ key: randomCpuKey });

            projectiles = [];

            document.getElementById('player-name').textContent = player.name;
            document.getElementById('cpu-name').textContent = cpu.name;

            timeLeft = 60;
            document.getElementById('timer').textContent = timeLeft;
            updateHealthBars();

            clearInterval(timer);
            timer = setInterval(() => {
                timeLeft--;
                document.getElementById('timer').textContent = timeLeft;
                if (timeLeft <= 0) {
                    endGame();
                }
            }, 1000);

            gameLoop();
        }

        function updateHealthBars() {
            const playerHealthPercent = (player.health / player.maxHealth) * 100;
            document.getElementById('player-health-bar').style.width = `${playerHealthPercent}%`;
            document.getElementById('player-health-text').textContent = `${Math.ceil(player.health)}/${player.maxHealth}`;

            const cpuHealthPercent = (cpu.health / cpu.maxHealth) * 100;
            document.getElementById('cpu-health-bar').style.width = `${cpuHealthPercent}%`;
            document.getElementById('cpu-health-text').textContent = `${Math.ceil(cpu.health)}/${cpu.maxHealth}`;
        }

        function collisionDetection({ fighter1, fighter2 }) {
            return (
                fighter1.attackBox.position.x + fighter1.attackBox.width >= fighter2.position.x &&
                fighter1.attackBox.position.x <= fighter2.position.x + fighter2.width &&
                fighter1.attackBox.position.y + fighter1.attackBox.height >= fighter2.position.y &&
                fighter1.attackBox.position.y <= fighter2.position.y + fighter2.height
            );
        }

        function endGame(isTimeout = false) {
            cancelAnimationFrame(gameLoopId);
            clearInterval(timer);

            let message = '';
            let coinsEarned = 0;

            if (isTimeout || player.health === cpu.health) {
                message = "It's a Draw!";
                coinsEarned = 50;
            } else if (player.health > cpu.health) {
                message = 'You Win!';
                coinsEarned = 150;
            } else {
                message = 'You Lose!';
                coinsEarned = 25;
            }

            playerState.coins += coinsEarned;
            saveData();
            updateCoinDisplays();

            gameOverMessage.textContent = message;
            coinsEarnedMessage.textContent = `You earned ${coinsEarned} coins!`;
            gameOverModal.classList.remove('hidden');
        }

        const keys = {
            left: { pressed: false },
            right: { pressed: false },
        };

        function simpleCpuAI() {
            // A more challenging CPU AI
            const distanceX = player.position.x - cpu.position.x;
            const inAttackRange = Math.abs(distanceX) <= cpu.attackBox.width;

            // --- Movement Logic ---
            // The CPU will now try to maintain an optimal distance, sometimes advancing, sometimes retreating.
            if (inAttackRange) {
                // When in range, decide whether to attack or back off
                if (Math.random() < 0.03) { // 3% chance each frame to back away
                     cpu.velocity.x = distanceX > 0 ? -cpu.speed * 0.75 : cpu.speed * 0.75;
                } else {
                     cpu.velocity.x = 0; // Stop to attack
                }
            } else {
                // If not in range, close the distance. This fixes the corner bug.
                cpu.velocity.x = distanceX > 0 ? cpu.speed : -cpu.speed;
            }

            // --- Attacking Logic ---
            if (inAttackRange) {
                // Higher chance to attack when in range
                if (Math.random() < 0.04) {
                    cpu.performAttack();
                }
                // More strategic use of specials
                if (Math.random() < 0.015) {
                   cpu.performSpecial();
                }
            }

             // --- Defensive Logic ---
            // Add random jumps to be more unpredictable
            if (Math.random() < 0.005 && cpu.velocity.y === 0) {
                cpu.velocity.y = -20;
            }
        }

        function gameLoop() {
            gameLoopId = requestAnimationFrame(gameLoop);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            player.update();
            cpu.update();

            // Player movement
            player.velocity.x = 0;
            if (keys.left.pressed) {
                player.velocity.x = -player.speed;
            } else if (keys.right.pressed) {
                player.velocity.x = player.speed;
            }

            // Player attack collision
            if (player.isAttacking && collisionDetection({ fighter1: player, fighter2: cpu })) {
                player.isAttacking = false; // Prevent multiple hits from one attack
                cpu.takeDamage(player.attack);
            }

            // CPU attack collision
            if (cpu.isAttacking && collisionDetection({ fighter1: cpu, fighter2: player })) {
                cpu.isAttacking = false;
                player.takeDamage(cpu.attack);
            }

            // Projectiles
            projectiles.forEach((proj, index) => {
                proj.update();
                let target = proj.owner === player ? cpu : player;

                // Projectile collision
                if (proj.position.x < target.position.x + target.width &&
                    proj.position.x + proj.width > target.position.x &&
                    proj.position.y < target.position.y + target.height &&
                    proj.position.y + proj.height > target.position.y) {

                    target.takeDamage(proj.damage);
                    projectiles.splice(index, 1);
                }

                // Remove off-screen projectiles
                if (proj.position.x < 0 || proj.position.x > canvas.width) {
                    projectiles.splice(index, 1);
                }
            });

            simpleCpuAI();

            // Check for game over condition
            if (player.health <= 0 || cpu.health <= 0) {
                endGame();
            }
        }

        // --- DATA PERSISTENCE ---
        function saveData() {
            localStorage.setItem('fighterGameState', JSON.stringify(playerState));
        }

        function loadData() {
            const savedState = localStorage.getItem('fighterGameState');
            if (savedState) {
                playerState = JSON.parse(savedState);
            }
        }


        // --- EVENT LISTENERS ---
        window.addEventListener('keydown', (event) => {
            if (!player) return;
            switch (event.key) {
                case 'ArrowLeft':
                    keys.left.pressed = true;
                    break;
                case 'ArrowRight':
                    keys.right.pressed = true;
                    break;
                case 'ArrowUp':
                    if (player.velocity.y === 0) player.velocity.y = -20;
                    break;
                case ' ': // Spacebar
                    player.performAttack();
                    break;
                case 's':
                case 'S':
                    player.performSpecial();
                    break;
            }
        });

        window.addEventListener('keyup', (event) => {
            if (!player) return;
            switch (event.key) {
                case 'ArrowLeft':
                    keys.left.pressed = false;
                    break;
                case 'ArrowRight':
                    keys.right.pressed = false;
                    break;
            }
        });

        buttons.play.addEventListener('click', () => {
            populateCharacterSelect();
            switchScreen('characterSelect');
        });

        buttons.shop.addEventListener('click', () => {
            populateShop();
            switchScreen('shop');
        });

        buttons.startFight.addEventListener('click', () => {
            switchScreen('game');
            initGame();
        });

        buttons.backToMenuFromChar.addEventListener('click', () => switchScreen('mainMenu'));
        buttons.backToMenuFromShop.addEventListener('click', () => switchScreen('mainMenu'));

        buttons.playAgain.addEventListener('click', () => {
            gameOverModal.classList.add('hidden');
            populateCharacterSelect();
            switchScreen('characterSelect');
        });

        buttons.backToMenuFromGameOver.addEventListener('click', () => {
            gameOverModal.classList.add('hidden');
            switchScreen('mainMenu');
        });

        buttons.closeUpgradeModal.addEventListener('click', () => {
            upgradeModal.classList.add('hidden');
            populateShop(); // Refresh shop to show any changes
        });

        buttons.download.addEventListener('click', () => {
            const fullHtml = document.documentElement.outerHTML;
            const blob = new Blob([fullHtml], { type: 'text/html' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'fighters_conquest.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        });

        // --- INITIALIZATION ---
        function initializeApp() {
            loadData();
            updateCoinDisplays();
            switchScreen('mainMenu');
        }

        initializeApp();

    </script>
</body>
</html>